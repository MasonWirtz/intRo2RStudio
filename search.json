{
  "articles": [
    {
      "path": "about.html",
      "title": "Preliminaries",
      "description": "Starting information about the workshop\n",
      "author": [
        {
          "name": "Mason A. Wirtz",
          "url": "https://masonwirtz.github.io"
        }
      ],
      "contents": "\n\nContents\nGetting started\nCreate an OSF account (voluntary)\nPrevious knowledge\nTopics\nLanguage\n\nGetting started\nIn this workshop, we will learn the basics of (a) using the free programming language R; (b) how to work in RStudio; (c) how to write and format reports using R Markdown and (d) how to structure R projects in a manner that eases the workflow when working quantitatively, but also facilitates easy reproducibility of the analyses. The workshop is geared towards PhD students interested in working quantitatively and is freely open to any interested faculty as well as MA students. All parts of the workshop will include hands-on exercises. At the end of the workshop, you will also have free time to use your own data, ask me questions and get feedback.\nCreate an OSF account (voluntary)\nThe second part of this workshop is going to deal with open data and reproducibility. One of the most used open data repositories is the Open Science Framework (OSF). Accounts are, of course, free and easy to set up. Under this link you can find a guide on how to create an account. Feel free to browse the website—take a look at other peoples’ repositories: How do they structure their open data? What trends do you see? Do some structures seem to make more or less sense to you? Of course, you don’t have to do this in preperation for the workshop, but it can certainly never hurt!\nYou won’t explicitely need an OSF account for this workshop, so this step is really entirely up to you. I would, however, highly recommend it—especially because you can store data here. If you create a repository, it is not automatically open to the public. You can store 5GB of data (of whatever type) in a repository, and it is one of the most secure networks for the sciences. You can then create a share-only like or edit link for collaboration. As far as I am aware, there is no limit to the amount of repositories you can create, so you can use this to collaborate—it is absolutely great!\nAs soon as a repository is open to the public, you then have 50GB of storage on the respective project/repository (since the goal here is, after all, open data/open science). We will go through a few walk-throughs of the website and how you can also store more than 5GBs on a private repository, if you should ever need that.\nPrevious knowledge\nIn general, there is no previous knowledge required to partake in this workshop, but very basic experience with R or RStudio is definitely helpful, as we will be covering the basics relatively quickly.\nI highly reccomend, before coming to this workshop, that you read the first chapter of Bodo Winter’s Statistics for Linguists: An Introduction using R if you have not worked with R until this workshop. Even if you don’t work along with the exercises in the book, simply reading the first chapter will give you a feel of what R is as a programming language. And if you are also in need of an introduction to the regression framework, this book is one for you!\nAlternatively, I can highly recommend Michael Franke’s An Introduction to Data Analysis, chapters 2.1–2.3, for a beginning look at R.\nTopics\nParticipants should leave this workshop with surer footing in the following areas:\nBasic coding in RStudio (we will largely use the Tidyverse)\nTypes of variables (vectors, factors, data frames)\nImporting data\nSetting up an R Markdown document\nEnsuring reproducible and understandable code\nStructuring an R project (folders, files, project management etc.)\nUsing OSF (Open Science Framework) to store data\nLanguage\nThe workshop material will be in English, but questions/discussions can be in German.\nSince most of the literature I have read hitherto (and most of the existing literature) on the topics we will be covering in this workshop are in English, I personally feel more comfortable speaking and creating the necessary material in English, as I’m not entirely sure I could explain the concepts with the correct vocabulary in German. This is my own personal shortcoming, and I apologize if this is an inconvenience for anyone.\n\n\n\n",
      "last_modified": "2022-02-22T12:30:22+01:00"
    },
    {
      "path": "DataGeneration.html",
      "title": "Data generation script",
      "author": [
        {
          "name": "Mason A. Wirtz",
          "url": "https://masonwirtz.github.io"
        }
      ],
      "contents": "\nThis script shows the code for generating the necessary data frames used in the workshop.\n\n\nlibrary(tidyverse)\n\nVampires =\n  tibble(\n  idVampire = 1:100,\n  gender = rnorm(n = 100, mean = 0, sd = 1),\n  ageOfVampire = abs(round(rnorm(n = 100, mean = 80, sd = 30))),\n  deadOrAlive = rnorm(n = 100, mean = 0, sd = 1),\n  hasFangs = rnorm(n = 100, mean = 0, sd = 1),\n  bornIn = rnorm(n = 100, mean = 5, sd = 2),\n  visitedCities = round(abs(exp(rnorm(n = 100, mean = 3, sd = 1)))),\n  numberOfChildren = round(abs(rnorm(n = 100, mean = 3, sd = 2))),\n  numberChangedToVamp = round(abs(exp(rnorm(n = 100, mean = 2, sd = .5))))\n) %>%\n  mutate(idVampire = as.factor(idVampire),\n         gender = ifelse(gender < 0, \"Male\", \"Female\"),\n         deadOrAlive = ifelse(deadOrAlive < 0, \"Dead\", \"Alive\"),\n         hasFangs = ifelse(hasFangs < 0, \"Yes\", \"No\"),\n         bornIn = ifelse(bornIn < 1, \"Asia\",\n                         ifelse(bornIn >= 1 & bornIn < 2, \"Africa\",\n                                ifelse(bornIn >= 2 & bornIn < 3, \"Europa\",\n                                       ifelse(bornIn >= 3 & bornIn < 4, \"North America\",\n                                              ifelse(bornIn >= 4 & bornIn < 5, \"South America\",\n                                                     ifelse(bornIn >= 5 & bornIn < 6, \"Australia\", \"Antarctica\")))))))\n\nwrite_csv(Vampires, file = \"./Data/Vampires.csv\") # write the file\n\n\n\nExport the mtcars and swiss data frames as a .csv files to upload to the workshop website.\n\n\nwrite_csv(mtcars, file = \"./Data/mtcars.csv\")\n\nwrite_csv(swiss, file = \"./Data/swiss.csv\")\n\n\n\n\n\n\n",
      "last_modified": "2022-02-22T12:30:25+01:00"
    },
    {
      "path": "ExercisesUnit2.html",
      "title": "2. Baby steps: Basics of coding in RStudio, part 1",
      "author": [
        {
          "name": "Mason A. Wirtz",
          "url": "https://masonwirtz.github.io"
        }
      ],
      "contents": "\n\nContents\nExercise 1\nExercise 2\nExercise 3\nExercise 4\nExercise 5\nExercise 6\nExercise 7\n\nExercise 1\nCreate an object (i.e. variable, container) called testObject and store five numbers in it.\n\nClick for Answer\nCreating and storing different types of vectors is one of the most essential skills you will need for using R. These first few exercises may seem really trivial, but I promise, you will use these trivial skills so often that you will quickly realize how not trivial they are.\nSOLUTION\nOkay, so we need an object called testObject. This part is easy enough. All I have to do is type testObject. The tricky part is storing something in the object. In this example, we just need to store five numbers in this object. Let’s go ahead and make our lives easy by just using the numbers 1 through 5. We can store the numbers 1 through 5 in an object in a few different ways. Let’s have a look at those few different ways.\nThe way a beginner thinks would probably be to save the numbers in the object like so:\n\n\ntestObject = c(1, 2, 3, 4, 5)\n\n\n\nThis most certainly isn’t wrong, and we achieved our goal. Good, right? Yes, it is! If you did something similar above, that’s great. It means you’ve gotten a grasp on the basics.\nBut, let’s say we want to be lazy. If I have even ten numbers, typing the number and comma is a lot of work. I don’t like work. So let’s make a our lives a little easier by using the fabulous : that R provides us with to make a sequence of numbers, like so:\n\n\ntestObject = 1:5\n\n\n\nSince we are also not stringing numbers together, but using the sequence operator :, we do not need to concatenate function c()–you can use it if you want, but you don’t need it.\nEverything clear? Hervorragend, then let’s move on to the next exercise.\nExercise 2\nCreate a character vector of your name and save it as the object Name\nHINT: The individual elements of a character vector must be under quotation marks\n\nClick for Answer\nSOLUTION\nI tend to use character vectors quite often (we will hear later in this workshop why), so I find it important to take a little bit of time to get to know them.\nIf we want a character vector consisting of different individual elements, then you know what that means: IT’S CONCATINATE TIME! We need the c() in order to string together different character elements, like so:\n\n\nName = c(\"Mason\", \"Allen\", \"Wirtz\")\n\n\n\nOf course, if you don’t need individual character elements (but I prefer them and oftentimes you also need the individual elements), you can also solve this without concatenating things.\n\n\nName = \"Mason Allen Wirtz\"\n\n\n\nBut, using the c() and creating individual character elements gives us more freedom to play around with the vector. More on this later.\nExercise 3\nCreate a vector named numbers and save the sequence 1–100 in it.\n\nClick for Answer\nSOLUTION\nI hinted about this above: If we want to have a larger data frame, it would take us sooooo long to do c(1, 2, 3, 4, 5, 6, …), I personally would die of boredom. Luckily, we can use the : operator and let R work its magic and create us a sequence of numbers between 1 and 100, namely like so:\n\n\nnumbers = 1:100\n\n\n\nExercise 4\nIn R, we have arithmetic operators (we will go into logical operators later) with which we can do simple math. Below, you can find a list of these, which are all very self-explanatory.\nOperator\nDescription\n+\nAddition\n-\nSubtraction\n*\nMultiplication\n/\nDivision\n^ OR **\nExponentiation\nAdd 1 and 1 together to get two\n\nClick for Answer\nSOLUTION\nI think this one is pretty self-explanatory, but just in case:\n\n\n1 + 1\n\n\n[1] 2\n\nExercise 5\nWe can also add vectors together, provided they are numeric. Add the two vectors below together–why does R throw an error?\n\n\na = 4:9\nb = 10:17\n\n\n\nWhat would we need to do in order to fix this error?\n\nClick for Answer\nSOLUTION\nOnly vectors of the same length can meaningfully be added/subtracted etc. Since vector a contains six values, and vector b eight values, R added the fist six values together of the two vectors. Since vector b is longer than vector a though, the last two numbers in vector b were added to the first two numbers in vector a. Basically, vector b realized, “oh no, there are no more numbers in vector a, what do I do?! Oh, I know, I’ll take the first two numbers of vector a and add them to my own last two values!”. R threw us an error to make us aware of this.\nExercise 6\nCreate two vectors (using whatever numerical values you’d like) under the names a and b (the two variables above will be overwritten) and divide the two vectors.\n\nClick for Answer\nSOLUTION\nNothing we haven’t already seen here. We’ll start with generating two vectors, like so:\n\n\na = 1:100\nb = 101:200\n\n\n\nAnd then let’s go ahead and just divide them by each other. The lovely thing about vectors and being able to save them as objects is that it makes doing simple arithmetic operations like this so easy and readable!\n\n\na/b\n\n\n  [1] 0.00990099 0.01960784 0.02912621 0.03846154 0.04761905\n  [6] 0.05660377 0.06542056 0.07407407 0.08256881 0.09090909\n [11] 0.09909910 0.10714286 0.11504425 0.12280702 0.13043478\n [16] 0.13793103 0.14529915 0.15254237 0.15966387 0.16666667\n [21] 0.17355372 0.18032787 0.18699187 0.19354839 0.20000000\n [26] 0.20634921 0.21259843 0.21875000 0.22480620 0.23076923\n [31] 0.23664122 0.24242424 0.24812030 0.25373134 0.25925926\n [36] 0.26470588 0.27007299 0.27536232 0.28057554 0.28571429\n [41] 0.29078014 0.29577465 0.30069930 0.30555556 0.31034483\n [46] 0.31506849 0.31972789 0.32432432 0.32885906 0.33333333\n [51] 0.33774834 0.34210526 0.34640523 0.35064935 0.35483871\n [56] 0.35897436 0.36305732 0.36708861 0.37106918 0.37500000\n [61] 0.37888199 0.38271605 0.38650307 0.39024390 0.39393939\n [66] 0.39759036 0.40119760 0.40476190 0.40828402 0.41176471\n [71] 0.41520468 0.41860465 0.42196532 0.42528736 0.42857143\n [76] 0.43181818 0.43502825 0.43820225 0.44134078 0.44444444\n [81] 0.44751381 0.45054945 0.45355191 0.45652174 0.45945946\n [86] 0.46236559 0.46524064 0.46808511 0.47089947 0.47368421\n [91] 0.47643979 0.47916667 0.48186528 0.48453608 0.48717949\n [96] 0.48979592 0.49238579 0.49494949 0.49748744 0.50000000\n\nWhat R did here was divide each number in the vector a by the number in the same position in vector b (i.e. 1/101, 2/102, 3/103 etc.), so we should wind up with a vector of 100 values in total.\nExercise 7\nAlright, let’s say we ran an experiment and tested the reaction times of a language learner once a day for seven days. We have the reaction times (these are provided for you, see below), but we want to make a vector with the days of the week.\nCreate a character vector with the days of the week and save it as daysOfTheWeek\n\nreactionTimes = rnorm(n = 7, mean = .25, sd = .1) # you don't need to do anything here\n\ndaysOfTheWeek =\n\n\nClick for Answer\nSOLUTION\nAll we have to do here is string together the days of the week and save it under the object daysOfTheWeek, only this time we have a character vector (similar to what we had with our name).\n\n\nreactionTimes = rnorm(n = 7, mean = .25, sd = .1) # you don't need to do anything here\n\ndaysOfTheWeek = c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\")\n\n\n\nThere is also a nice little base R function (we will learn more about functions later) called weekdays(), which takes a date as an argument. I put together a few variations of how to generate weekdays using this function, in case anyone ever really needs to add this to a data set. Just run the code lines and have a quick look at the output.\nIt’s probably important to mention here: There is always an elegant solution to any question, and probably an easier way to do it. While typing the whole vector our like in my solution above is easy, these solutions are also quite elegant and easily readable. Just food for thought.\n\n\nweekdays(ISOdate(1, 1, 1:7))\n\n\n[1] \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"   \n[6] \"Saturday\"  \"Sunday\"   \n\nweekdays(Sys.Date()+0:6) # days of the week starting on whatever day today is\n\n\n[1] \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"    \"Saturday\" \n[6] \"Sunday\"    \"Monday\"   \n\nweekdays(as.Date(4,\"1970-01-01\",tz=\"GMT\")+0:6)\n\n\n[1] \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"   \n[6] \"Saturday\"  \"Sunday\"   \n\nWe could then combine these two vectors to create a data frame using the function data.frame() from base R (we will learn more about functions in the next section), like so:\n\n\ndata.frame(daysOfTheWeek, reactionTimes)\n\n\n  daysOfTheWeek reactionTimes\n1        Monday     0.2359437\n2       Tuesday     0.3460718\n3     Wednesday     0.1637444\n4      Thursday     0.1217074\n5        Friday     0.4072964\n6      Saturday     0.3919663\n7        Sunday     0.2434204\n\n\n\n\n",
      "last_modified": "2022-02-22T12:30:26+01:00"
    },
    {
      "path": "ExercisesUnit3.html",
      "title": "3. Baby steps: Basics of coding in RStudio, part 2",
      "author": [
        {
          "name": "Mason A. Wirtz",
          "url": "https://masonwirtz.github.io"
        }
      ],
      "contents": "\n\nContents\nExercise 1\nExercise 2\nExercise 3\nExercise 4\nExercise 5\nExercise 5.1\nExercise 5.2\n\nExercise 6\n\nExercise 1\nSo we’ve gotten to know a few different functions. But what do we do if we don’t know the particular arguments a function takes?\nLet’s image we want to generate some random data coming from a Poisson distribution. The function provided to us is rpois(), which basically means “random numbers from a Poisson distribution”.\nIn the help pane, type in rpois (or type ?rpois in the console). What arguments does the function rpois() take?\n\nClick for Answer\nSOLUTION\n\n\n?rpois\n\n\n\nThe rpois() function takes the arguments n (i.e. number of values that should be generated) and the argument lambda (i.e. the mean and the variance, in other words the expected number of events in a given (time) interval).\nExercise 2\nLet’s get to using the actual functions. You looked up the arguments the rpois() function takes.\nHINT lambda specifies the mean and variance of a count process—basically, it’s the expected number of events/successes in a given interval.\nGenerate 10000 random values from the Poisson distribution with a lambda of 3 and save it under the object Poisson.\n\nClick for Answer\nSOLUTION\nAlright, so in the previous exercise, we had a look at the arguments that the function rpois takes. We know that it takes the argument n (i.e. the number of values that should be generated). The exercise asks us to generate 10000 random values, so this must be our n value. The function also takes the argument lambda, which the exercise tells us should be 3. We then want to save this as an object named Poisson.\nLet’s see how we can do this:\n\n\nPoisson = rpois(n = 10000, lambda = 3)\n\n\n\nExercise 3\nSo, you’ve generated (maybe your first?) Poisson distribution, yay!\nLet’s say we now want to plot the random data we just generated. Go to the help pane and look up the arguments for the function hist(). BUT, instead of plotting the FREQUENCY of each value, we want the PROBABILITY. How would we do this? What argument do we need to adjust?\nHINT The plot that you generate should look similar to this one (but don’t fret if the values are a bit different, we are all generating RANDOM values, after all, so they will differ a bit):\n\n\nPoisson = tibble(Poisson = rpois(n = 10000, lambda = 3))\n\nPoisson %>% \n  ggplot(aes(x = Poisson, \n             y = stat(count / sum(count)))) + \n  geom_histogram(binwidth = 1, \n                 color = \"black\") + \n  geom_vline(xintercept = 3, \n             color = \"red\", \n             alpha = .5,\n             linetype = \"dashed\") + \n  labs(x = \"Count/Number of successes\",\n       y = \"Probability\",\n       title = \"10000 samples of Pois(lambda = 3)\") + \n  theme_bw()\n\n\n\n\n\nClick for Answer\nSOLUTION\nSo, we want to plot our generated data, not as frequencies, but as probabilities, using the function hist(). Our first step here should be to go ahead and look at the arguments that the function takes. Theoretically, we can change the arguments freq and probability in order to get the probability density of the values. If we change the probability argument, we can change it to true (we can write this as TRUE or T, for short). We can also change the freq argument to FALSE, which throws back the probability density as well, so we should end up with the same plot either way.\n\n\nPoisson = rpois(n = 10000, lambda = 3) # generate the data again\n\nhist(Poisson, probability = T)\nhist(Poisson, freq = F)\n\n\n\n\n(Fun side note: The Poisson distribution is being used more and more in linguistics, since it is the canonical distribution for characterizing count data. If you want to e.g. compute a model where your DV is the number of errors produced, number of dialect realizations in an interaction, number of case markers etc., the Poisson distribution should become your new best friend. Bodo Winter’s book Statistics for Linguists has an entire chapter dedicated to the Poisson distribution, I would definitely recommend a read.)\nExercise 4\nCalculate the mean and standard deviation of the number of people the vampires have changed into vampires. Take a look at the data frame and the names of the data frame—which variable do we need?\nHINT You will need the $ operator.\n\n\nmean()\nsd()\n\n\n\n\nClick for Answer\nSOLUTION\nSince I didn’t specify which variable we are interested in, we would need to search the data frame to find out which variable we need. If we just need to remind ourselves which variable we are interested in, we can do this using the colnames() function, which returns the names of the columns, but no information on what is actually in the columns. If we want to see what is actually in the columns without having to print the entire data frame, we can go ahead and use the head() function.\n\n\ncolnames(Vampires)\n\n\n[1] \"idVampire\"           \"gender\"              \"ageOfVampire\"       \n[4] \"deadOrAlive\"         \"hasFangs\"            \"bornIn\"             \n[7] \"visitedCities\"       \"numberOfChildren\"    \"numberChangedToVamp\"\n\nhead(Vampires)\n\n\n# A tibble: 6 × 9\n  idVampire gender ageOfVampire deadOrAlive hasFangs bornIn       \n      <dbl> <chr>         <dbl> <chr>       <chr>    <chr>        \n1         1 Male            121 Alive       No       Australia    \n2         2 Male             99 Alive       No       Antarctica   \n3         3 Female           56 Alive       Yes      North America\n4         4 Male             46 Alive       Yes      Antarctica   \n5         5 Female           40 Alive       No       South America\n6         6 Male             51 Alive       Yes      South America\n# … with 3 more variables: visitedCities <dbl>,\n#   numberOfChildren <dbl>, numberChangedToVamp <dbl>\n\nAfter exploring the data frame, we should find that the variable numberChangedToVamp is the one we are looking for.\nNow that we know which variable we need, the exercise asks us to calculate the mean and standard deviation. We need the $ operator in order to go into the data frame and select exactly this variable. We will then wrap this in the two functions mean() and sd(), like so:\n\n\nmean(Vampires$numberChangedToVamp)\n\n\n[1] 8.4\n\nsd(Vampires$numberChangedToVamp)\n\n\n[1] 4.490169\n\nExercise 5\nThis exercise is best done in small groups.\nIn the help pane, look up the functions rep(), as.factor() and gl(). Which arguments do these functions take?\nIn the next few steps, we will go through how to create a data frame (this exercise begins here, and we will continue it in the next set of exercises—here, we are just focusing on generating two variables, namely ID and Time, see below for more details).\nWhy, you might ask, are we focusing so much on generating data? For one, it get’s you in the rhythm of looking up the arguments in functions—that’s something you will always have to do. Second, it’s great to know and understand how to generate data. Let’s say, for example, we want to run an a priori power analysis for a mixed effects model to find out how likely we are to find an effect OR to judge how large of a sample we might need. Since a priori power analyses for mixed effects models basically can only be done via computer simulations, we need to be able to generate data and data frames. The following steps are a good exercise in developing this ability. Another plus in being able to generate data is you will be able to write your R scripts before you are finished collecting data in an experiment, i.e. you can just generate similar data to which you are collecting, write your analyses code in advance and once you have your data, you have a whole lot less work. Before you are able to generate data, you won’t really see what you’re missing out on—once you can do it, you won’t know how you ever lived without being able to do this.\nSo, let’s start:\nResearch context: We are interested in whether weekly exposure to the L2 during intensive L2 learning in mid-age (between 25–45) has an effect on reaction times in a Stroop task (i.e. how long it takes a participant to click when the color of the word and the word itself are the same). The participants partake in an intensive language learning course over a 20-week period in the target language community, and we test them once a week. There are 15 participants.\nLet’s generate some data for this!\nExercise 5.1\nTo start, we need to generate an ID variable for the participants (remember, these ID numbers need to be some sort of factors!). That means: We want to generate IDs as factors for 15 participants, where each participant is tested 20 times (i.e. each participant ID has to show up 20 times).\nWhich function can we use to do this (HINT you looked it up in the first part of this task!)?\nSave this as an object under the name ID.\n\nClick for Answer\nSOLUTION\nAlright, we want to generate the ID variable for all participants. Since we have 15 participants, we know we will need the numbers (as factors) 1–15. That part is easy enough. The tricky part is repeating the 1–15 20 times (for each data collection point).\nIf you looked at the required functions in the first part of this exercise, a bell hopefully went off in your mind saying that you can use the gl() function, which stands for “generate levels”. This function generates factor levels, and we need the arguments n (number of levels, so this needs to be 15, since we have 15 participants), and k (which is the number of replications, which needs to be 20, since we have 20 data collection points and need to generate each participant’s ID 20 times). So, we need the following code:\n\n\nID = gl(n = 15, k = 20) # Create ID variables for 20 data collection times\n\n\n\nExercise 5.2\nAlright, so we have our participant ID variable. Now we need a variable called Time, i.e. 20 data collection points per participant. You will need the function rep(x = ..., times = ...) for this.\n\nTime = rep(x = ???, times = ???)\n\n\nClick for Answer\nSOLUTION\nSo, now things get a bit tricky. We need to generate the sequence 1–20 a total of 15 times (the sequence once for each participant). We were given in the exercise the function rep(), which can take the arguments x (the sequence, so 1–20), and times (i.e. how many times should she sequence be repeated?). Thus, we need to enter the following code:\n\n\nTime = rep(x = 1:20, times = 15)\n\n\n\nBUT, this generates a numeric vector. Time points are not numeric, so we need a factor. We can do this a few different ways. For one, we can use the as.factor() function to transform the entire vector into factors, like so:\n\n\nas.factor(Time)\n\n\n  [1] 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 1 \n [22] 2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 1  2 \n [43] 3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 1  2  3 \n [64] 4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 1  2  3  4 \n [85] 5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 1  2  3  4  5 \n[106] 6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 1  2  3  4  5  6 \n[127] 7  8  9  10 11 12 13 14 15 16 17 18 19 20 1  2  3  4  5  6  7 \n[148] 8  9  10 11 12 13 14 15 16 17 18 19 20 1  2  3  4  5  6  7  8 \n[169] 9  10 11 12 13 14 15 16 17 18 19 20 1  2  3  4  5  6  7  8  9 \n[190] 10 11 12 13 14 15 16 17 18 19 20 1  2  3  4  5  6  7  8  9  10\n[211] 11 12 13 14 15 16 17 18 19 20 1  2  3  4  5  6  7  8  9  10 11\n[232] 12 13 14 15 16 17 18 19 20 1  2  3  4  5  6  7  8  9  10 11 12\n[253] 13 14 15 16 17 18 19 20 1  2  3  4  5  6  7  8  9  10 11 12 13\n[274] 14 15 16 17 18 19 20 1  2  3  4  5  6  7  8  9  10 11 12 13 14\n[295] 15 16 17 18 19 20\nLevels: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n\nIf we want to do everything in one step, we can just wrap one function within another, transforming the numeric vector 1:20 into a factor in the first step, like so:\n\n\nTime = rep(x = as.factor(1:20), times = 15) # Repeat 1 through 20 as factors 15 times\nTime\n\n\n  [1] 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 1 \n [22] 2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 1  2 \n [43] 3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 1  2  3 \n [64] 4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 1  2  3  4 \n [85] 5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 1  2  3  4  5 \n[106] 6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 1  2  3  4  5  6 \n[127] 7  8  9  10 11 12 13 14 15 16 17 18 19 20 1  2  3  4  5  6  7 \n[148] 8  9  10 11 12 13 14 15 16 17 18 19 20 1  2  3  4  5  6  7  8 \n[169] 9  10 11 12 13 14 15 16 17 18 19 20 1  2  3  4  5  6  7  8  9 \n[190] 10 11 12 13 14 15 16 17 18 19 20 1  2  3  4  5  6  7  8  9  10\n[211] 11 12 13 14 15 16 17 18 19 20 1  2  3  4  5  6  7  8  9  10 11\n[232] 12 13 14 15 16 17 18 19 20 1  2  3  4  5  6  7  8  9  10 11 12\n[253] 13 14 15 16 17 18 19 20 1  2  3  4  5  6  7  8  9  10 11 12 13\n[274] 14 15 16 17 18 19 20 1  2  3  4  5  6  7  8  9  10 11 12 13 14\n[295] 15 16 17 18 19 20\nLevels: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n\nExercise 6\nInstall and load the package reshape2.\n\nClick for Answer\nSOLUTION\nIf you haven’t installed this package before, we need to first install the package before we can actually load it, using the install.packages() function. After that, we need to load in the package using the library() function, like so:\n\n\ninstall.packages(\"reshape2\")\nlibrary(reshape2)\n\n\n\n\n\n\n",
      "last_modified": "2022-02-22T12:30:29+01:00"
    },
    {
      "path": "ExercisesUnit4.html",
      "title": "4. The tidier the better: Basics of coding with the Tidyverse",
      "author": [
        {
          "name": "Mason A. Wirtz",
          "url": "https://masonwirtz.github.io"
        }
      ],
      "contents": "\n\nContents\nExercise 1\nExercise 2\nExercise 3\nExercise 4\nExercise 5\nExercise 5.1\nExercise 5.2\n\nExercise 6 (for experts)\n\nExercise 1\nLoad in the data Vampires (preferably as a tibble using the read_csv() function).\nWe are only interested in the columns idVampire, gender, ageOfVampire and numberOfChildren. Create a new data frame called Vamps including only these columns.\n\nClick for Answer\nSOLUTION\nSince our goal here is to simply subset the data frame and select on certain columns, we can use the function select() from the dplyr package included in the tidyverse. This will allow us to pick and choose which columns we want to subset. We can then assign these subsetted variables to a new object, which the directions ask us to call Vamps. Let’s go ahead and do this:\n\n\nVamps = Vampires %>% \n  select(idVampire, gender, ageOfVampire, numberOfChildren)\n\n\n\nSince the first three columns we want to subset are in a row (i.e. the first three columns), we can also easily specify 1:3 (i.e. columns 1 through 3), plus the variable numberOfChildren, like so:\n\n\nVamps = Vampires %>% \n  select(1:3, numberOfChildren)\n\n\n\nExercise 2\nCalculate the mean amount of cities the vampires have visited (variable: visitedCities), as well as the standard deviation thereof, using the summarize() function.\n\nClick for Answer\nSOLUTION\nAs always, our first step is to reach into the data frame we are interested in, namely Vampires, and then simply use the summarize function, like so:\n\n\nVampires %>% \n  summarize(mean = mean(visitedCities), \n            sd = sd(visitedCities))\n\n\n# A tibble: 1 × 2\n   mean    sd\n  <dbl> <dbl>\n1  29.6  47.1\n\nExercise 3\nCalculate the mean age of male and female vampires.\nHINT You will need the pipe ( %>% ) to group/stack functions, the group_by function and the summarize function (in that order).\n\nClick for Answer\nSOLUTION\nAlright, so our first step, as always, is to specify which data frame we are interested in. Then we want to group our data frame into two groups, namely male and female, which can be done by using the group_by() function on the variable gender. After that, we need the summarize() function to calculate the mean age (variable: ageOfVampire), like so:\n\n\nVampires %>% \n# Group the data frame by the gender variable, which is binary, i.e. only male or female. \n  group_by(gender) %>% \n# Summarize the grouped data \n  summarize(mean = mean(ageOfVampire))\n\n\n# A tibble: 2 × 2\n  gender  mean\n  <chr>  <dbl>\n1 Female  78.3\n2 Male    85.1\n\nExercise 4\nAlright, now we can get to the fun stuff: Manipulating data.\nTo start off, let’s clean up our environment a bit. We won’t really be needing the Vamps data frame we made earlier, so remove it from your environment using the rm(Vamps) function.\nLet’s say we are interested in whether alive vampires have changed more people into vampires depending on whether they have fangs or not. The variables here that will interest us are deadOrAlive, hasFangs and numberChangedToVamp. There is no need to subset the respective variables, but if you want to for the sake of practice, go ahead.\nWhat is the mean number of people the alive vampires WITH and WITHOUT fangs have turned into vampires?\nHINT You will need the pipe ( %>% ) to group/stack functions, the filter function, the group_by function and the summarize function (in that order).\n\nClick for Answer\nSOLUTION\nThis is pretty tricky, there are three steps we need to go through to get to the answer. Let’s go through this together.\nTo start with, we know that we are only interested in ALIVE vampires, so this means that we need to subset the data frame to home in on only the vampires that are alive. Our variable deadOrAlive tells us whether the vampires are dead or alive, so this is the variable we first need to subset. We do this by using the filter() function (remember, filter is for ROWS and select is for COLUMNS). And we specify we only want ALIVE vampires by using the == operator (REMEMBER, the operator = is for assigning values to an object, == means “is equal to”).\nNow, since we are interested in whether vampires with and without fangs have changed more people to vampires, we need to group our data frame into two groups: vampires WITH fangs and vampires WITHOUT fangs. We can do this by using the group_by() function.\nLastly, we then need the summarize function and specify it to give us the mean of the people the vampires WITH and WITHOUT fangs have changed into vampires.\nWe have an interesting outcome, vampires without fangs have changed more people into vampires on average than vampires with fangs…interesting. Maybe vampires without fangs have a Minderwertigkeitskomplex…?\n\n\nVampires %>% \n# Filter the data frame so that it ONLY includes vampires that are ALIVE\n  filter(deadOrAlive == \"Alive\") %>% \n# Group the data frame by the hasFangs variable, which is binary, i.e. only yes or no. \n  group_by(hasFangs) %>% \n# Summarize the grouped data \n  summarize(mean = mean(numberChangedToVamp))\n\n\n# A tibble: 2 × 2\n  hasFangs  mean\n  <chr>    <dbl>\n1 No        7.85\n2 Yes       7.37\n\nExercise 5\nRemember how we started generating data in the previous set of exercises? Let’s go back to that. To remind you, we generated the ID variable using the gl() function (generate levels) and Time variable (data collection points, ranging from point 1 to point 20), using the rep() function.\nIn case you didn’t get to that exercise, run the following code to catch up:\n\n\nID = gl(n = 15, k = 20) # Create ID variables for 20 data collection times\nTime = rep(x = as.factor(1:20), times = 15) # Repeat 1 through 20 as factors 15 times\n\n\n\nWe will continue building a data frame—I have generated a new variable for you, namely weeklyExposure, which should be understood as the total number of hours per week participants spend engaging with native speakers. Run the following code to generate this variable. If you have not already installed the reshape2 package, you can do so by using the function install.packages(\"reshape2\").\n\n\n# install.packages(\"reshape2\") # delete the # and run if you have not yet installed the reshape2 package\nlibrary(reshape2)\nweeklyExposure = replicate(20, rexp(n = 15, rate = .05)) # create expo. increasing values\nweeklyExposure = weeklyExposure %>% \n  melt() %>% \n  mutate(weeklyExposure = ifelse(weeklyExposure %in% \"value\" > 80, 80, weeklyExposure),\n         weeklyExposure = ifelse(weeklyExposure %in% \"value\" < 0, 0, weeklyExposure),\n         weeklyExposure = round(weeklyExposure, digits = 2)) %>% \n  select(weeklyExposure)\n\n\n\nExercise 5.1\nNow, let’s combine these three variables into a single data frame. Use the function tibble(). Please save this tibble under the object name df.\n\nClick for Answer\nSOLUTION\n\n\ndf = tibble(ID, Time, weeklyExposure)\n\n\n\nExercise 5.2\nWe would like to have a new variable in this data frame that we make using the contents of the other variables.\nOur new variable should be the weeklyExposure variable log transformed. This variable should be added to the data frame df. Call this new variable logWeeklyExposure.\nHINT To add a new variable to a data frame within the tidyverse framework, we need the mutate() function. To log transform a variable, we need the log() function.\n\nClick for Answer\nSOLUTION\nTo create a new variable, we need the mutate() function. We can then specify how we would like to mutate the contents of a variable in the data frame. Since we simply want to log transform the weeklyExposure variable, we just need to apply the log() function to the weeklyExposure variable.\n\n\ndf = df %>% \n  mutate(logWeeklyExposure = log(weeklyExposure))\n\n# Check df to make sure we got this new variable \ndf\n\n\n# A tibble: 300 × 4\n   ID    Time  weeklyExposure logWeeklyExposure\n   <fct> <fct>          <dbl>             <dbl>\n 1 1     1               6.46              1.87\n 2 1     2              52.5               3.96\n 3 1     3              34.3               3.54\n 4 1     4              34.4               3.54\n 5 1     5               5.81              1.76\n 6 1     6              24.2               3.19\n 7 1     7               0.01             -4.61\n 8 1     8               6.05              1.80\n 9 1     9              16.8               2.82\n10 1     10             22.9               3.13\n# … with 290 more rows\n\nExercise 6 (for experts)\nAlright, you’ve done well until now? Great! Let’s take on a harder task. Before you start, look up the arguments for the function ungroup().\nLet’s say we had participants complete several versions of a C Test (a language assessment test in which participants have to complete words—this has been shown to strongly correlate with participants’ general language proficiency, cf. Raatz & Klein–Braley [2002]). Since no two tests are typically exactly the same, even after pilot testing (that is, without conducting large-scale psycho-metric validity screenings), we tend to correct for the possible differences in the tasks statistically. We can correct for differences (to help ensure better comparability) between the versions of the C Test by subtracting or adding the deviation of each version’s mean count from the overall mean count for each individual score.\nLet me generate some data for you that replicates this situation:\n\n\nCTest_df = \n  tibble(Version = gl(n = 3, k = 20),\n       CTest = c(round(abs(rnorm(n = 20, mean = 17, sd = 4))), \n                 round(abs(rnorm(n = 20, mean = 19, sd = 4))), \n                 round(abs(rnorm(n = 20, mean = 20, sd = 4))))\n) %>% \n  mutate(CTest = ifelse(CTest > 30, 30, CTest), # just in case there are any wild deviations\n         CTest = ifelse(CTest < 0, 0, CTest)) # just in case there are any wild deviations\n\n# Let's have a look\nCTest_df\n\n\n# A tibble: 60 × 2\n   Version CTest\n   <fct>   <dbl>\n 1 1          22\n 2 1          16\n 3 1          20\n 4 1          10\n 5 1          13\n 6 1          22\n 7 1          14\n 8 1          21\n 9 1          21\n10 1          17\n# … with 50 more rows\n\nCTest_df %>% \n  group_by(Version) %>% \n  summarize_at(.vars = \"CTest\", \n               .funs = c(\"max\", \"min\", \"mean\", \"sd\"))\n\n\n# A tibble: 3 × 5\n  Version   max   min  mean    sd\n  <fct>   <dbl> <dbl> <dbl> <dbl>\n1 1          25    10  17.8  3.56\n2 2          28    10  20.1  4.81\n3 3          28    13  20    4.39\n\nSo, now we have a data frame with the version of the C Test (Version) and each participant’s score on the C Tests (CTest).\nAdjust the variable CTest by subtracting or adding the difference of each C Test version’s mean score from the overall mean score of the C Tests from or to each individual score.\nHINT You will need to (or can, there are other ways to solve this) use the following functions in the given order: group_by(), mutate(), ungroup() and mutate()\n\nClick for Answer\nSOLUTION\nSee the commented code below for the solution\n\n\nCTest_df %>% \n# First we need to group by version, since we need the mean of each VERSION of the CTest\n  group_by(Version) %>% \n# Now we create a NEW variable called CTestMean, which gives us the mean of each version\n  mutate(CTestMean = mean(CTest)) %>% \n# We haven't seen this function yet, but what it does is the exact opposite of the group_by() function, \n# but instead of grouping the different levels of a factor, it ungroups them to give us back\n# the actual data frame, just now with the new variable (i.e. CTestMean) we just created\n  ungroup() %>% \n# Now we need to create a few different variables: \n  # We need the OVERALL mean, i.e. the mean of ALL the C Test scores; \n  # We need the difference between the OVERALL mean score and the mean scores of each version of the C test\n  # We then change the original CTest variable by adding the difference (positive or negative)\n    # to each individual CTest score\n  mutate(CTestMean_overall = mean(CTestMean), \n         CTestMean_difference = CTestMean_overall - CTestMean, \n         CTest = CTest + CTestMean_difference) %>% \n# Now we just get rid of the extra noise variables that we needed to calculate the adjusted C Test scores\n  select(-c(CTestMean, CTestMean_overall, CTestMean_difference))\n\n\n# A tibble: 60 × 2\n   Version CTest\n   <fct>   <dbl>\n 1 1        23.5\n 2 1        17.5\n 3 1        21.5\n 4 1        11.5\n 5 1        14.5\n 6 1        23.5\n 7 1        15.5\n 8 1        22.5\n 9 1        22.5\n10 1        18.5\n# … with 50 more rows\n\n\n\n\n",
      "last_modified": "2022-02-22T12:30:32+01:00"
    },
    {
      "path": "ExercisesUnit5.html",
      "title": "5. Setting up a project",
      "author": [
        {
          "name": "Mason A. Wirtz",
          "url": "https://masonwirtz.github.io"
        }
      ],
      "contents": "\n\nContents\nExercise 1\nExercise 2\nExercise 2.1\nExercise 2.2\nExercise 2.3\nExercise 2.4 (Experts)\n\n\nExercise 1\nCreate a new R script in RStudio. Save this script in the script folder we created in our new project structure.\nOn the workshop website, download the data frame mtcars and save this in the data folder we created in our new project structure.\nUsing the read_csv() function, load the data frame mtcars into your global environment and save this data frame under the variable name cars. Remember to use a RELATIVE PATH when loading in this data.\nHINT: Don’t forget to put the call in parentheses, and don’t forget the .\n\nClick for Answer\nSOLUTION\nIf we use the read_csv function, we are loading in our data as a tibble, which is really neat (thanks to the tidyverse package(s)). When we read in data from other folders, i.e. from places that are not in the same folder that our script is saved, we need to define the RELATIVE path, which in this case is \"./Data/mtcars.csv\". Since this data is saved in the Data folder, but our script is in the Script folder, we need to jump OUT of the Scripts folder (which is what the . does), and then jump INTO the Data folder (which is what the /Data/) does. Once we have defined this as our RELATIVE path, we can then enter the name of the data frame we want to load (which is mtcars.csv).\n\n\ncars = read_csv(\"./Data/mtcars.csv\")\n\n\n\nExercise 2\nWhen dealing with data, we oftentimes have functions that we write ourselves, because we use them over and over again. For example, if you used a questionnaire and formed items in the negative, you need to reverse this scale. An easy way to do this is to write a function that you can then use on all the items formulated in the reverse.\nExercise 2.1\nCreate a new folder in our folder structure called Functions (you can do this on your regular user system, i.e. how you would normally create a new folder). Make sure this folder is in the R you ready folder structure.\nDownload the script from the workshop website called reverseItems_Functions.R from the Exercise scripts drop-down pane. Save this script (saved under THE SAME NAME) in the functions folder.\nExercise 2.2\nOnce we have the functions saved in the Functions folder, we can use the lovely source() function to call up these functions and use them in a new script. I am a fan of the source() function (and maybe even overuse it…). It takes as its argument a RELATIVE path to an .R file.\nSource the reverseItems_Functions.R file that you saved in the Functions folder, using the RELATIVE path to this .R document. DON’T FORGET THE PARENTHESES!!\n\nClick for Answer\nUsing the relative path, we can source in the functions (and the data frame I included in this script). The source function runs and loads the script in its entirety, so if you created variables, data frames etc. in this script, those will be loaded along with the functions you wrote.\n\n\nsource(\"./Functions/reverseItems_Functions.R\")\n\n\n\nExercise 2.3\nLook at the variable item_6.3 using the call df_items$item_6.3. Then use the linkScaleRev6 function on the variable item_6.3. What did this function do?\n\nClick for Answer\nYou guessed it, this home-made function reversed the scale, turning 1s into 6s, 2s into 5s, and so forth. Isn’t that practical?!\nExercise 2.4 (Experts)\nTake a look at the reverseItems_Functions.R document and the functions I wrote. Write a function that reverses 7-scale items using the ifelse statement. Call this function linkScaleRev7 that takes the argument of an item\n\nClick for Answer\nIf you understood the functions I wrote, this activity shouldn’t be all that challenging :) All you need to do is add an extra ifelse() function to the mix, so that the entire scale is reversed.\n\n\n# reverse a 6-scale item ----\nlinkScaleRev7 =\n  function(item){\n    ifelse(item == 1, 7,\n           ifelse(item == 2, 6,\n                  ifelse(item == 3, 5,\n                         ifelse(item == 4, 4,\n                                ifelse(item == 5, 3,\n                                       ifelse(item == 6, 2, \n                                              ifelse(item == 7, 2, NA)))))))\n  }\n\n\n\n\n\n\n",
      "last_modified": "2022-02-22T12:30:32+01:00"
    },
    {
      "path": "ExercisesUnit6.html",
      "title": "6. Code chunks in R Markdown",
      "author": [
        {
          "name": "Mason A. Wirtz",
          "url": "https://masonwirtz.github.io"
        }
      ],
      "contents": "\n\nContents\nExercise 1\nExercise 2\n\nExercise 1\nCreate a new code chunk using the Insert button in RStudio. In your new code chunk, complete the following exercise:\nUse the ifelse() function to create a new categorical variable called VampOld: All vampires older than 100 should be categorized as Old, all vampires younger than 100 should be categorized as Young.\nHINT You will need the mutate() function and the ifelse() function.\n\nClick for Answer\nSOLUTION\nSince we are interested in creating a new variable, this should tell us immediately that we need the mutate() function. In the mutate() function, we need to define our new variable VampOld.\nOnce we have defined the new variable, we need to define what should be included in the new variable. Since we want to categorize the age variable (which we really wouldn’t ever want to do in real life, but for practice, it’s an easy example), we can use the ifelse() statement, which first takes an argument to evaluate. The argument to evaluate we need to supply the function with is “if the vampire is older than 100…”, which we can do using the variable ageOfVampire and the > operator. Once we have supplied the ‘if’ argument, we need the ‘then do’ argument, i.e. what needs to happen when this argument is true? In this case, all vampires older than 100 should be categorized as ‘old’, so we supply the function with ‘old’. The final argument in the function takes the ‘else’ part, i.e. what happens when the first argument is false? Since we just want to categorize the variable into old and young, if the vampire is not old, then they must be young, so we supply the final argument with the character value ‘young’.\n\n\nVampires = Vampires %>% \n  mutate(VampOld = ifelse(ageOfVampire > 100, \"Old\", \"Young\"))\n\n\n\nExercise 2\n\n\n\n",
      "last_modified": "2022-02-22T12:30:33+01:00"
    },
    {
      "path": "ExercisesUnit7.html",
      "title": "7. Let’s get plotting",
      "author": [
        {
          "name": "Mason A. Wirtz",
          "url": "https://masonwirtz.github.io"
        }
      ],
      "contents": "\n\n\n\n",
      "last_modified": "2022-02-22T12:30:33+01:00"
    },
    {
      "path": "index.html",
      "title": "IntRo to RStudio and R Markdown",
      "author": [
        {
          "name": "Mason A. Wirtz",
          "url": "https://masonwirtz.github.io"
        }
      ],
      "contents": "\nLet’s get started!\nPrerequisites\nThe first step is to download RStudio. If you have not done so already, you can find the links and the directions on how to do this here.\nUsing this website\nThis website accompanies the workshop. All slides are available on this page, as well as on this workshop’s OSF page.\nThe hands-on exercises are all available as R scripts under Exercise scripts—the exact same exercises AND THEIR SOLUTIONS (hidden, unless you click the Click for answer button under each exercise) are available Exercises. All solutions have thorough explanations so you can reference them again and again in the future if need be.\nWhen doing the exercises, you can feel free to use the provided R scripts, or feel free to make your own R scripts and simply copy/paste the exercises from the workshop website. This is entirely up to you (I personally find the exercises on the workshop website far more readable, but, like I said, however you feel most comfortable completing the exercises). The solutions are only available under the tab Exercises.\nCheck list\nHere is a summary of all the prepping steps.\n\nDownload RStudio (essential)\n\nCreate an OSF account here (optional)\n\nBrowse the Getting started pages\n\n\n\n",
      "last_modified": "2022-02-22T12:30:34+01:00"
    },
    {
      "path": "Schedule.html",
      "title": "Schedule",
      "author": [
        {
          "name": "Mason A. Wirtz",
          "url": "https://masonwirtz.github.io"
        }
      ],
      "contents": "\n\nContents\nSchedule\nDay 1. Getting wet in the coding waters: Basics of RStudio\n1. Introduction to RStudio\n2. Baby steps: Basics of coding in RStudio, part 1\n3. Baby steps: Basics of coding in RStudio, part 2\n4. The tidier the better: Basics of coding with the Tidyverse\n\nDay 2. Give me an R for reproducibility: Basics of R Markdown\n5. Setting up a project\n6. Code chunks in R Markdown\n7. Let’s get plotting\n8. Reporting and reproducibility\n9. You don’t just knit with needles: Knitting in R Markdown\n10. Fun with coding\n\n\n\nSchedule\nDay 1. Getting wet in the coding waters: Basics of RStudio\n1. Introduction to RStudio\nWhich panes exist?\nHow can I read in data?\n2. Baby steps: Basics of coding in RStudio, part 1\nVectors\nFactors\nData frames\n3. Baby steps: Basics of coding in RStudio, part 2\nObjects\nFunctions\nPackages\n4. The tidier the better: Basics of coding with the Tidyverse\nTibbles\nData wrangling with dplyr\nPiping with magritter\nDay 2. Give me an R for reproducibility: Basics of R Markdown\n5. Setting up a project\nHow do I create an .Rproj file?\nHow can/should I structure my folders/files?\nRelative/absolute file paths\n6. Code chunks in R Markdown\nWhat is a code chunk in R Markdown?\nStructuring code chunks\n7. Let’s get plotting\nPlotting with ggplot2\nSaving ggplots\n8. Reporting and reproducibility\nR Markdown syntax\nInline formatting\nBlock-level elements\n9. You don’t just knit with needles: Knitting in R Markdown\nKnitting an HTML document\nKnitting a Word document\nUploading/downloading from OSF\n10. Fun with coding\nWorking with your own data\nQuestions, individual work\nNote: If you don’t have your own data, send me a short description of your project and I will simulate data similar to the data you will be working with so that you have something to practice!\n\n\n\n",
      "last_modified": "2022-02-22T12:30:34+01:00"
    }
  ],
  "collections": []
}
